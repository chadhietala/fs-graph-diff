<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

<script src="./node_modules/graphlib/dist/graphlib.min.js"></script>
<script src="http://cpettitt.github.io/project/graphlib-dot/latest/graphlib-dot.min.js"></script>
<script src="./node_modules/viz.js/viz.js"></script>

<div style="border: 1px solid; padding: 20px;">
<h1>Single Root</h1>

<h2>Create</h2>
<div id="create"></div>

<h2>Idemponent</h2>
<div id="idempotent"></div>

<h2>Remove Dependency</h2>
<div id="remove"></div>

<h2>Add back Dependency</h2>
<div id="add-back"></div>

<h2>Add Dependency With Transitive</h2>
<div id="add-transitive"></div>

<h2>Unroot</h2>
<div id="unroot"></div>

<h2>Reroot</h2>
<div id="reroot"></div>

<h2>Unroot + add dependency</h2>
<div id="unroot-add"></div>
</div>

<div style="border: 1px solid; padding: 20px; margin-top: 20px;">
<h1>Multi-root</h1>
<div id="multi-create"></div>

<h2>Idemponent</h2>
<div id="multi-idempotent"></div>

<h2>Remove Dependency</h2>
<div id="multi-remove"></div>

<h2>Add Back Dependency</h2>
<div id="multi-add-back"></div>

<h2>Add Dependency With Shared Boundary</h2>
<div id="multi-shared-boundary"></div>
</div>
<script>
const Graph = graphlibDot.graphlib.Graph;
const write = graphlibDot.write;
const postOrder = graphlibDot.graphlib.alg.postorder;
const components = graphlibDot.graphlib.alg.components;

class Module {
  constructor(root, name, parent) {
    this.root = root;
    this.name = name;
    this._parent = parent;
    this._roots = [];
  }

  isRooted() {
    return this._roots.length > 0;
  }

  unrooted(name) {
    let index = this._roots.indexOf(name);
    if (index > -1) {
      this._roots.splice(1, index);
    }
  }

  rooted(name) {
    if (!this._roots.includes(name)) {
      this._roots.push(name);
    }
  }

  chain(root, name) {
    let mod = new Module(root, name, this);
    if (this._parent !== 'root') {
      mod.rooted(this._parent.root);
    }

    return mod;
  }
}

class FSGraph {
  constructor() {
    this.roots = [...arguments];
    this.graph = new Graph();
    this.dependencyStack = [];
    this.moduleInfos = null;
  }

  _isRootEntry(potentialRoot) {
    return this.roots.includes(potentialRoot);
  }

  create(patches, moduleInfos) {
    this.moduleInfos = moduleInfos;
    patches.forEach(([, relativePath]) => {
      let ns = this._ns(relativePath);
      let moduleInfo = moduleInfos[ns];

      for (let i = 0; i < moduleInfo.files.length; i++) {
        let fileName = moduleInfo.files[i].name;
        if (fileName === relativePath) {
          this._appendNode(ns, relativePath, moduleInfo.files[i]);
          break;
        }
      }
    });

    this.prune();
  }

  update(patches, moduleInfos) {
    let [op, relativePath] = patches[0];
    if (JSON.stringify(this.moduleInfos) !== JSON.stringify(moduleInfos)) {
      this.moduleInfos = moduleInfos;
      switch (op) {
        case 'update':
          this._update(patches, moduleInfos);
          break;
        case 'delete':
          this._remove(patches, moduleInfos);
          break;
        case 'create':
          this.create(patches, moduleInfos);
          break;
      }
    }
  }

  _remove(patches, moduleInfos) {
    patches.forEach(([, relativePath]) => {
      this._removeNodes(relativePath);
    });
  }

  _removeNodes(relativePath) {
    let outEdges = this.graph.outEdges(relativePath);
    outEdges.forEach(({ v: _vertix, w: _node }) => {
      this.graph.removeEdge(_vertix, _node);
      let module = this.graph.node(_node);
      let inEdges = this.graph.inEdges(_node) || [];

      if (inEdges.length === 0) {
        let outEdges = this.graph.outEdges(_node);
        this._removeNodes(_node);
        this.graph.removeNode(_node);
      }
    });

    this.graph.removeNode(relativePath);
  }

  _update(patches, moduleInfos) {
    patches.forEach(([, relativePath]) => {
      let ns = this._ns(relativePath);
      let moduleInfo = moduleInfos[ns];
      for (let i = 0; i < moduleInfo.files.length; i++) {
        let fileName = moduleInfo.files[i].name;
        if (fileName === relativePath) {
          this._verifyNode(ns, relativePath, moduleInfo.files[i]);
          break;
        }
      }
    });
  }

  _verifyNode(ns, relativePath, moduleInfo) {
    let outEdges = this.graph.outEdges(relativePath);
    if (moduleInfo.imports.length === 0) {
      outEdges.forEach((edge) => {
        let { w } = edge;
        this.graph.removeNode(w);
      });
    } else {
      moduleInfo.imports.forEach(({ source }) => source);
      outEdges.forEach(({ w: outEdge }) => {
        if (!moduleInfo.imports.includes(outEdge)) {
          this.graph.removeNode(outEdge);
        }
      });

      moduleInfo.imports.forEach(({ source }) => {
        if (!this.graph.node(source)) {
          this._appendNode(ns, relativePath, moduleInfo);
        }
      });
    }
  }

  _getRoots() {
    let nodes = this.graph.nodes();
    let rooted = {};
    nodes.forEach((name) => {
      let { root } =  this.graph.node(name);
      if (this._isRootEntry(root)) {
        if (rooted[root] && !rooted[root].includes(name)) {
          rooted[root].push(name);
        } else if (!rooted[root]) {
          rooted[root] = [name];
        }
      }
    });

    return rooted;
  }

  prune() {
    let pruned = {};
    let roots = this._getRoots();
    let rootNames = Object.keys(roots);

    rootNames.forEach((root) => {
      let _roots = roots[root];
      _roots.forEach((name) => {
        let connected = postOrder(this.graph, name);
        if (pruned[root]) {
          pruned[root] = pruned[root].concat(connected.filter((node) => {
            return !pruned[root].includes(node);
          }))
        } else {
          pruned[root] = connected;
        }
      })
    });


    let nodes = this.graph.nodes();

    Object.keys(pruned).forEach((root) => {
      nodes.forEach((node) => {
        let module = this.graph.node(node);

        if (!module || !module.isRooted()) {
          this.graph.removeNode(node);
        }
      });
    });
  }

  _appendNode(root, relativePath, moduleInfo) {
    let module = this.graph.node(relativePath);

    if (!module) {
      module = new Module(root, relativePath, 'root');
      this.graph.setNode(relativePath, module);
    }

    if (this._isRootEntry(root)) {
      module.rooted(relativePath);
    }

    moduleInfo.imports.forEach((dependency) => {
      let dependencyName = `${dependency.source}.js`;
      let dependencyModule = this.graph.node(dependencyName);
      let ns = this._ns(dependencyName);

      if (!dependencyModule) {
        dependencyModule = module.chain(ns, dependencyName);
      }

      // transitively mark dependencies as rooted
      if (module.isRooted()) {
        dependencyModule.rooted(relativePath);
      }

      this.graph.setNode(dependencyName, dependencyModule);
      this.graph.setEdge(relativePath, dependencyName);

      let [depsOfDep] = this.moduleInfos[ns].files.filter((file) => file.name === dependencyName);

      if (depsOfDep.imports.length > 0) {
        this._appendNode(dependencyModule.root, dependencyName, depsOfDep);
      }

    });
  }

  _ns(relativePath) {
    let [ns] = relativePath.split('/');
    return ns;
  }

  serialize() {
    return write(this.graph)
  }
}


let graph = new FSGraph('my-app');
let moduleInfo = {
  "my-app": {
    files: [
      {
        name: 'my-app/router.js',
        imports: [
          {
            source: 'my-addon/utils/messaging',
            specifiers: [
              {
                imported: 'default',
                kind: 'name',
                local: 'Messaging'
              }
            ]
          }
        ]
      },
      {
        name: 'my-app/main.js',
        imports: []
      },
      {
        name: 'my-app/ui/components/foo-bar/component.js',
        imports: []
      }
    ]
  },
  "my-addon":     {
    files: [
      {
        name: 'my-addon/utils/messaging.js',
        imports: []
      },
      {
        name: 'my-addon/utils/strings.js',
        imports: []
      },
      {
        name: 'my-addon/ui/components/baz-bar/component.js',
        imports: [
          {
            source: 'my-addon/utils/messaging',
            specifiers: [
              {
                imported: 'default',
                kind: 'name',
                local: 'Messaging'
              }
            ]
          }
        ]
      }
    ]
  }
};

const patches =   [
    ['create', 'my-app/router.js'],
    ['create', 'my-app/main.js'],
    ['create', 'my-app/ui/components/foo-bar/component.js'],
    ['create', 'my-addon/ui/components/baz-bar/component.js'],
    ['create', 'my-addon/utils/strings.js'],
    ['create', 'my-addon/utils/messaging.js']
];


graph.create(
  patches,
  moduleInfo
);

document.getElementById('create').innerHTML = Viz(graph.serialize());

// Idemponent change as far as dependencies go


graph.update(
  [['update', 'my-app/router.js']],
  moduleInfo
);


document.getElementById('idempotent').innerHTML = Viz(graph.serialize());


// Remove the dependency
let copy = JSON.parse(JSON.stringify(moduleInfo));
copy['my-app'].files[0].imports = [];

graph.update(
  [['update', 'my-app/router.js']],
  copy
);

document.getElementById('remove').innerHTML = Viz(graph.serialize());

// Add the dependency back
graph.update(
  [['update', 'my-app/router.js']],
  moduleInfo
);

document.getElementById('add-back').innerHTML = Viz(graph.serialize());

copy = JSON.parse(JSON.stringify(moduleInfo));

// Add new import with transitive dependency

copy['my-app'].files[0].imports.push({
  source: 'my-addon/utils/strings',
  specifiers: [
    {
      imported: 'STRING_1',
      kind: 'name',
      local: 'STRING_1'
    },
    {
      imported: 'STRING_2',
      kind: 'name',
      local: 'STRING_2'
    }
  ]
});

copy['my-addon'].files[1].imports.push({
  source: 'my-addon/ui/components/baz-bar/component',
  specifiers: [
    {
      imported: 'default',
      kind: 'name',
      local: 'MyThing'
    }
  ]
});


graph.update(
  [['update', 'my-app/router.js']],
  copy
);

document.getElementById('add-transitive').innerHTML = Viz(graph.serialize());

// Unroot a file

copy = JSON.parse(JSON.stringify(copy));
let stash = copy['my-app'].files.shift();

graph.update(
  [['delete', 'my-app/router.js']],
  copy
);

document.getElementById('unroot').innerHTML = Viz(graph.serialize());

copy = JSON.parse(JSON.stringify(copy));

copy['my-app'].files.unshift(stash);

graph.update(
  [['create', 'my-app/router.js']],
  copy
);

document.getElementById('reroot').innerHTML = Viz(graph.serialize());

copy = JSON.parse(JSON.stringify(copy));

stash = copy['my-app'].files.shift(stash);

graph.update(
  [['delete', 'my-app/router.js']],
  copy
);

copy = JSON.parse(JSON.stringify(copy));


copy['my-app'].files[1].imports.push({
  source: 'my-addon/ui/components/baz-bar/component',
  specifiers: [
    {
      imported: 'default',
      kind: 'name',
      local: 'Component'
    }
  ]
});

console.log(copy['my-app'].files[1]);

debugger;
graph.update(
  [['update', 'my-app/ui/components/foo-bar/component.js']],
  copy
)

document.getElementById('unroot-add').innerHTML = Viz(graph.serialize());


/***************************************/

graph = new FSGraph('my-app', 'my-engine');
let enginePatches = [['create', 'my-engine/router.js'], ...patches];
moduleInfo = JSON.parse(JSON.stringify(moduleInfo));

moduleInfo["my-engine"] = {
  files: [
    {
      name: 'my-engine/router.js',
      imports: [
      ]
    },
  ]
};

stash =  [{
  source: 'my-addon/utils/strings',
  specifiers: [
    {
      imported: 'STRING_1',
      kind: 'name',
      local: 'STRING_1'
    }
  ]
},
{
  source: 'my-addon/ui/components/baz-bar/component',
  specifiers: [
    {
      imported: 'STRING_1',
      kind: 'name',
      local: 'STRING_1'
    }
  ]
}]

graph.create(enginePatches, moduleInfo);

document.getElementById('multi-create').innerHTML = Viz(graph.serialize());

graph.update(['update', 'my-engine/router.js'], moduleInfo);

document.getElementById('multi-idempotent').innerHTML = Viz(graph.serialize());

copy = JSON.parse(JSON.stringify(moduleInfo));

copy['my-app'].files[0].imports = [];

graph.update([['update', 'my-app/router.js']], copy);

document.getElementById('multi-remove').innerHTML = Viz(graph.serialize());

graph.update([['update', 'my-app/router.js']], moduleInfo);

document.getElementById('multi-add-back').innerHTML = Viz(graph.serialize());

copy = JSON.parse(JSON.stringify(moduleInfo));

copy['my-engine'].files[0].imports = stash;

graph.update([['update', 'my-engine/router.js']], copy);

document.getElementById('multi-shared-boundary').innerHTML = Viz(graph.serialize());


// VISUALIZE
//document.body.innerHTML = Viz(graph.serialize());


</script>
</body>
</html>