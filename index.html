<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

<script src="./node_modules/graphlib/dist/graphlib.min.js"></script>
<script src="http://cpettitt.github.io/project/graphlib-dot/latest/graphlib-dot.min.js"></script>
<script src="./node_modules/viz.js/viz.js"></script>

<script>
const Graph = graphlibDot.graphlib.Graph;
const write = graphlibDot.write;
const postOrder = graphlibDot.graphlib.alg.postorder;
const components = graphlibDot.graphlib.alg.components;

class Module {
  constructor(root, name) {
    this.root = root;
    this.name = name;
    this._isRooted = false;
  }

  isRooted() {
    return this._isRooted;
  }

  rooted() {
    this._isRooted = true;
  }
}

class FSGraph {
  constructor() {
    this.roots = [...arguments];
    this.graph = new Graph();
    this.dependencyStack = [];
    this.moduleInfos = null;
  }

  _isRootEntry(potentialRoot) {
    return this.roots.includes(potentialRoot);
  }

  create(patches, moduleInfos) {
    this.moduleInfos = moduleInfos;
    patches.forEach(([, relativePath]) => {
      let ns = this._ns(relativePath);
      let moduleInfo = moduleInfos[ns];
      for (let i = 0; i < moduleInfo.files.length; i++) {
        let fileName = moduleInfo.files[i].name;
        if (fileName === relativePath) {
          this._appendNode(ns, relativePath, moduleInfo.files[i]);
          break;
        }
      }
    });

    this.prune();
  }

  update(patches, moduleInfos) {
    let [op, relativePath] = patches[0];
    if (JSON.stringify(this.moduleInfos) !== JSON.stringify(moduleInfos)) {
      switch (op) {
        case 'update':
          this._update(patches, moduleInfos);
          break;
        case 'delete':
          this._remove(patches, moduleInfos);
          break;
      }
    }
  }

  _remove() {

  }

  _update(patches, moduleInfos) {
    this.moduleInfos = moduleInfos;
    patches.forEach(([, relativePath]) => {
      let ns = this._ns(relativePath);
      let moduleInfo = moduleInfos[ns];
      for (let i = 0; i < moduleInfo.files.length; i++) {
        let fileName = moduleInfo.files[i].name;
        if (fileName === relativePath) {
          this._verifyNode(ns, relativePath, moduleInfo.files[i]);
          break;
        }
      }
    });
  }

  _addTransitives() {

  }

  _verifyNode(ns, relativePath, moduleInfo) {
    let outEdges = this.graph.outEdges(relativePath);
    if (moduleInfo.imports.length === 0) {
      outEdges.forEach((edge) => {
        let { w } = edge;
        this.graph.removeNode(w);
      });
    } else {
      moduleInfo.imports.forEach(({ source }) => source);
      outEdges.forEach(({ w: outEdge }) => {
        if (!moduleInfo.imports.includes(outEdge)) {
          this.graph.removeNode(outEdge);
        }
      });

      moduleInfo.imports.forEach(({ source }) => {
        if (!this.graph.node(source)) {
          this._appendNode(ns, relativePath, moduleInfo);
        }
      });
    }
  }

  _getRoots() {
    let nodes = this.graph.nodes();
    let rooted = {};
    nodes.forEach((name) => {
      let { root } =  this.graph.node(name);
      if (this._isRootEntry(root)) {
        if (rooted[root] && !rooted[root].includes(name)) {
          rooted[root].push(name);
        } else if (!rooted[root]) {
          rooted[root] = [name];
        }
      }
    });

    return rooted;
  }

  prune() {
    let pruned = {};
    let roots = this._getRoots();
    let rootNames = Object.keys(roots);

    rootNames.forEach((root) => {
      let _roots = roots[root];
      _roots.forEach((name) => {
        let connected = postOrder(this.graph, name);
        if (pruned[root]) {
          pruned[root] = pruned[root].concat(connected.filter((node) => {
            return !pruned[root].includes(node);
          }))
        } else {
          pruned[root] = connected;
        }
      })
    });

    let nodes = this.graph.nodes();

    Object.keys(pruned).forEach((root) => {
      nodes.forEach((node) => {
        let module = this.graph.node(node);
        if (!pruned[root].includes(node) || !module.isRooted()) {
          this.graph.removeNode(node);
        }
      });
    });
  }

  _appendNode(root, relativePath, moduleInfo) {
    let module = this.graph.node(relativePath);

    if (!module) {
      module = new Module(root, relativePath);
      this.graph.setNode(relativePath, module);
    }

    if (this._isRootEntry(root)) {
      module.rooted();
    }

    moduleInfo.imports.forEach((dependency) => {
      let dependencyName = `${dependency.source}.js`;
      let dependencyModule = this.graph.node(dependencyName);
      let ns = this._ns(dependencyName);

      if (!dependencyModule) {
        dependencyModule = new Module(ns, dependencyName);
      }

      // transitively mark dependencies as rooted
      if (module.isRooted()) {
        dependencyModule.rooted();
      }

      this.graph.setNode(dependencyName, dependencyModule);
      this.graph.setEdge(relativePath, dependencyName);

      let [depsOfDep] = this.moduleInfos[ns].files.filter((file) => file.name === dependencyName);

      if (depsOfDep.imports.length > 0) {
        this._appendNode(dependencyModule.root, dependencyName, depsOfDep);
      }

    });
  }

  _ns(relativePath) {
    let [ns] = relativePath.split('/');
    return ns;
  }

  serialize() {
    return write(this.graph)
  }
}


let graph = new FSGraph('my-app');
let moduleInfo = {
  "my-app": {
    files: [
      {
        name: 'my-app/router.js',
        imports: [
          {
            source: 'my-addon/utils/messaging',
            specifiers: [
              {
                imported: 'default',
                kind: 'name',
                local: 'Messaging'
              }
            ]
          }
        ]
      },
      {
        name: 'my-app/main.js',
        imports: []
      },
      {
        name: 'my-app/ui/components/foo-bar/component.js',
        imports: []
      }
    ]
  },
  "my-addon":     {
    files: [
      {
        name: 'my-addon/utils/messaging.js',
        imports: []
      },
      {
        name: 'my-addon/utils/strings.js',
        imports: []
      },
      {
        name: 'my-addon/ui/components/baz-bar/component.js',
        imports: [
          {
            source: 'my-addon/utils/messaging',
            specifiers: [
              {
                imported: 'default',
                kind: 'name',
                local: 'Messaging'
              }
            ]
          }
        ]
      }
    ]
  }
};

graph.create(
  [
    ['create', 'my-app/router.js'],
    ['create', 'my-app/main.js'],
    ['create', 'my-app/ui/components/foo-bar/component.js'],
    ['create', 'my-addon/ui/components/baz-bar/component.js'],
    ['create', 'my-addon/utils/strings.js'],
    ['create', 'my-addon/utils/messaging.js'],
  ],
  moduleInfo
);

// Idemponent change as far as dependencies go

graph.update(
  [['update', 'my-app/router.js']],
  moduleInfo
);

// Remove the dependency
let copy = JSON.parse(JSON.stringify(moduleInfo));
copy['my-app'].files[0].imports = [];

graph.update(
  [['update', 'my-app/router.js']],
  copy
);

// Add the dependency back
graph.update(
  [['update', 'my-app/router.js']],
  moduleInfo
);

copy = JSON.parse(JSON.stringify(moduleInfo));

// Add new import with transitive dependency

copy['my-app'].files[0].imports.push({
  source: 'my-addon/utils/strings',
  specifiers: [
    {
      imported: 'STRING_1',
      kind: 'name',
      local: 'STRING_1'
    },
    {
      imported: 'STRING_2',
      kind: 'name',
      local: 'STRING_2'
    }
  ]
});

copy['my-addon'].files[1].imports.push({
  source: 'my-addon/ui/components/baz-bar/component',
  specifiers: [
    {
      imported: 'default',
      kind: 'name',
      local: 'MyThing'
    }
  ]
});


// Add the dependency back
graph.update(
  [['update', 'my-app/router.js']],
  copy
);


// VISUALIZE
document.body.innerHTML = Viz(graph.serialize());


</script>
</body>
</html>